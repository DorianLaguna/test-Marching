<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Voxel Grid con Preview</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 1;
        background: rgba(0, 0, 0, 0.6);
        color: white;
        padding: 8px 12px;
        border-radius: 8px;
        font-family: sans-serif;
      }
      #toggle {
        padding: 5px 10px;
        font-size: 14px;
      }
    </style>
  </head>
  <body>
    <div id="ui">
      <button id="toggle">Modo: Agregar</button>
    </div>

    <script type="module">
      import Stats from "https://cdnjs.cloudflare.com/ajax/libs/stats.js/r17/Stats.min.js";
      import * as THREE from "three";
      import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
      import { MarchingCubes } from "three/examples/jsm/objects/MarchingCubes.js";

      const stats = new Stats();
      stats.showPanel(0); // 0 = FPS
      document.body.appendChild(stats.dom);

      let mode = "add";

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x202020);

      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(10, 10, 10);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      const gridHelper = new THREE.GridHelper(20, 20);
      scene.add(gridHelper);

      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(5, 10, 5);
      scene.add(light);

      const voxelSize = 1;
      const cubes = [];

      const cubeGeo = new THREE.OctahedronGeometry(voxelSize * 0.6); // Escala para que encaje
      const cubeMat = new THREE.MeshStandardMaterial({ color: 0x44aa88 });

      const resolution = 28; // Puedes ajustar la resolución para más detalle o rendimiento
      const marchingCubes = new MarchingCubes(
        resolution,
        new THREE.MeshPhongMaterial({ color: 0x44aa88, shininess: 100, flatShading: true }),
        true, // enableUvs
        true // enableColors
      );

      marchingCubes.position.set(0, 0, 0);
      marchingCubes.scale.set(1, 1, 1); // Escala según tu voxel size y espacio

      scene.add(marchingCubes);

	  function updateFieldFromVoxels(object, voxels) {
		object.reset();
		const strength = 0.8;
		const subtract = 0.3;

		voxels.forEach((cube) => {
			const worldPos = cube.position.clone().sub(marchingCubes.position);
			const x = worldPos.x / voxelSize + resolution / 2;
			const y = worldPos.y / voxelSize + resolution / 2;
			const z = worldPos.z / voxelSize + resolution / 2;

			object.addBall(x, y, z, strength, subtract);
		});
		}



      marchingCubes.scale.set(
        voxelSize * resolution,
        voxelSize * resolution,
        voxelSize * resolution
      );

      function addVoxel(pos) {
        const cube = new THREE.Mesh(cubeGeo, cubeMat.clone());
        cube.position.copy(pos);
        cube.userData.isVoxel = true;
        scene.add(cube);
        cubes.push(cube);
      }
	  const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
scene.add(ambientLight);

      // Agregar cubo base inicial
      addVoxel(new THREE.Vector3(0, 0, 0));

      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();

      // Preview cube
      const previewMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        opacity: 0.5,
        transparent: true,
      });
      const previewCube = new THREE.Mesh(cubeGeo, previewMat);
      previewCube.visible = false;
      scene.add(previewCube);

      // Actualizar mouse al mover
      window.addEventListener("mousemove", (event) => {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      });

      // Agregar o eliminar cubos al hacer clic
      window.addEventListener("click", () => {
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(cubes);

        if (intersects.length > 0) {
          const intersect = intersects[0];
          const clickedCube = intersect.object;

          if (mode === "add") {
            const normal = intersect.face.normal.clone();
            const newPos = clickedCube.position
              .clone()
              .add(normal.multiplyScalar(voxelSize));
            addVoxel(newPos);
          } else if (mode === "remove") {
            scene.remove(clickedCube);
            const i = cubes.indexOf(clickedCube);
            if (i > -1) cubes.splice(i, 1);
          }
        }
      });

      // Cambiar modo con el botón
      const button = document.getElementById("toggle");
      button.addEventListener("click", () => {
        mode = mode === "add" ? "remove" : "add";
        button.textContent = `Modo: ${mode === "add" ? "Agregar" : "Eliminar"}`;
      });

      function animate() {
        requestAnimationFrame(animate);
        stats.begin();
        controls.update();
		// marchingCubes.reset();
		// marchingCubes.addBall(resolution/2, resolution/2, resolution/2, 1.0, 0.1);

        updateFieldFromVoxels(marchingCubes, cubes);

        // Opcional: ocultar cubos voxel si quieres mostrar solo superficie
        //   cubes.forEach(cube => cube.visible = false);

        // Mostrar preview solo en modo agregar
        if (mode === "add") {
          raycaster.setFromCamera(mouse, camera);
          const intersects = raycaster.intersectObjects(cubes);
          if (intersects.length > 0) {
            const intersect = intersects[0];
            const normal = intersect.face.normal.clone();
            const position = intersect.object.position
              .clone()
              .add(normal.multiplyScalar(voxelSize));
            previewCube.position.copy(position);
            previewCube.visible = true;
          } else {
            previewCube.visible = false;
          }
        } else {
          previewCube.visible = false;
        }

        renderer.render(scene, camera);
        stats.end();
      }

      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
